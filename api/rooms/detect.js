// Vercel Serverless Function for room detection using Replicate
// Uses segmentation model + SAM2 for mask refinement

const REPLICATE_API_URL = 'https://api.replicate.com/v1/predictions';

// Segmentation model for indoor scenes
const SEGMENTATION_MODEL = 'cjwbw/semantic-segmentation:v1';
// SAM2 for mask refinement
const SAM2_MODEL = 'meta/sam-2-base:latest';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const apiKey = process.env.REPLICATE_API_KEY;
  if (!apiKey) {
    return res.status(500).json({ error: 'Replicate API key not configured' });
  }

  try {
    const { imageUrl } = req.body;

    if (!imageUrl) {
      return res.status(400).json({ error: 'Missing imageUrl' });
    }

    // For now, we'll use a simpler approach with OneFormer or similar
    // This creates mock room data based on image analysis
    // In production, you'd call the actual Replicate segmentation models

    // Call Replicate's segmentation model
    const segmentationResponse = await fetch(REPLICATE_API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Token ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        version: 'a]fb6547b8a2a76d5c8e9c9a2f0db8e7c8b5d8e2f1c3a4b5d6e7f8a9b0c1d2e3f4', // placeholder
        input: {
          image: imageUrl,
          task: 'panoptic',
        }
      })
    });

    // For demo purposes, return mock detected rooms
    // In production, this would parse the actual segmentation output
    const mockRooms = generateMockRooms(imageUrl);

    return res.status(200).json({
      rooms: mockRooms,
      imageWidth: 1024,
      imageHeight: 1024
    });

  } catch (error) {
    console.error('Room detection error:', error);
    return res.status(500).json({ error: error.message || 'Room detection failed' });
  }
}

// Generate mock rooms for development
// Replace with actual segmentation parsing in production
function generateMockRooms(imageUrl) {
  const roomTypes = [
    { label: 'Living Room', confidence: 0.95 },
    { label: 'Kitchen', confidence: 0.92 },
    { label: 'Bedroom', confidence: 0.89 },
    { label: 'Bathroom', confidence: 0.87 },
    { label: 'Hallway', confidence: 0.85 },
  ];

  // Create a grid-based layout of rooms
  const rooms = [];
  const gridSize = Math.ceil(Math.sqrt(roomTypes.length));
  const cellWidth = 100 / gridSize;
  const cellHeight = 100 / gridSize;

  roomTypes.forEach((room, index) => {
    const row = Math.floor(index / gridSize);
    const col = index % gridSize;

    const x = col * cellWidth + 5;
    const y = row * cellHeight + 5;
    const width = cellWidth - 10;
    const height = cellHeight - 10;

    rooms.push({
      id: `room-${index}`,
      label: room.label,
      confidence: room.confidence,
      bbox: {
        x: x,
        y: y,
        width: width,
        height: height
      },
      polygon: [
        { x: x, y: y },
        { x: x + width, y: y },
        { x: x + width, y: y + height },
        { x: x, y: y + height }
      ],
      maskUrl: null, // Would be generated by SAM2
      featherPx: 12
    });
  });

  return rooms;
}
